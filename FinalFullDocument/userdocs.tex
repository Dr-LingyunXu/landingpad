% !TEX root = DesignDocument.tex

\chapter{User Documentation}

This chapter will cover the usage instructions and how to install the software required to get the UAV up an running with a Pixhawk flight controller and a odroid xu4 companion computer. The User Guide section will cover how to run all the software installed during the Installation Guide. The Programmer Manual section will cover where to get up to speed with programming in ROS as well as details regarding the flight controller code that was used to demonstrate offboard control.

%% \newpage  %%  if needed ...
\section{Installation Guide}
The following two sections will go through the set up of a laptop or desktop as a workstation and the odroid that will be attached to the UAV.
\subsection{Setting Up a Workstation}
To set up the workstation the first thing that is required is a computer with \href{http://www.ubuntu.com/download/desktop}{Ubuntu} 14.04 Long Term Support(LTS) installed as the operating system. 
\subsubsection{Dependencies}
Once a Ubuntu machine is acquired make sure git and cmake are installed by running the following commands: 
\begin{lstlisting}[language=bash]
$ sudo apt-get install git
$ sudo apt-get install cmake
\end{lstlisting}
Then create the following two directories:
\begin{lstlisting}[language=bash]
$ mkdir -p catkin_ws/src cmake_ws
\end{lstlisting}
These directories will be used to manage the libraries and software required by the UAV. The cmake\_ws will contain the source of the libraries required by a semi-direct monocular visual odometry pipeline package in ROS also known as SVO. The catkin\_ws directory will contain the source for SVO and other packages that will be written and downloaded for the UAV. Before any of the ROS packages can be installed the dependencies for SVO will need to be installed. \\
\\
The following commands will install Sophus which is required by SVO:
\begin{lstlisting}[language=bash]
$ cd cmake_ws
$ git clone https://github.com/strasdat/Sophus.git
$ cd Sophus
$ git checkout a621ff
$ mkdir build
$ cd build
$ cmake ..
$ make
\end{lstlisting}
The following commands will install Fast detector which is used by SVO to detect corners:
\begin{lstlisting}[language=bash]
$ cd cmake_ws
$ git clone https://github.com/uzh-rpg/fast.git
$ cd fast
$ mkdir build
$ cd build
$ cmake ..
$ make
\end{lstlisting}
Once Sophus and Fast are installed the ROS packages can start to be installed to the system.
\subsubsection{ROS}
To install ROS refer to \url{http://wiki.ros.org/indigo/Installation/Ubuntu}. It will always have the most up to date installation instructions for installing ROS indigo onto Ubuntu. Everything has successfully worked under both indigo and jade versions of ROS. If ROS jade has reached EOL then indigo should be used. The commands and links are given with ros-indigo instead of ros-jade for this purpose.\\
\\ 
To install mavros, ar-track-alvar, and the camera driver the following commands needs to be executed:
\begin{lstlisting}[language=bash]
$ sudo apt-get install ros-indigo-mavros*
$ sudo apt-get install ros-indigo-ar-track alvar
$ sudo apt-get install ros-indigo-pointgrey-camera-driver
\end{lstlisting}
In order to install ROS packages the catkin workspace will have to be initialized so that ROS libraries can be found for ROS packages that are written by a user or to compile source code. \\
\\
To initialize the catkin workspace execute the following:
\begin{lstlisting}[language=bash]
$ cd catkin_ws/src
$ catkin_init_workspace
$ cd ..
$ catkin_make
$ source devel/setup.bash
\end{lstlisting}
The source command above can be added to the .bashrc file in the home directory so the workspace doesn't have to be explicitly sourced. This will allow usage of packages compiled in this directory without having to remember to source it. \\
\\
Before SVO can be installed a ROS dependency vikit will need to be downloaded into the workspace alongside SVO.
\begin{lstlisting}[language=bash]
$ cd catkin_ws/src
$ git clone https://github.com/uzh-rpg/rpg_vikit.git
$ git clone https://github.com/uzh-rpg/rpg_svo.git
$ cd ..
$ catkin_make
\end{lstlisting}
Once all the previous software is set up, a couple of items need to be moved to specific directories on the system. The flight controller directory in the landingpad repository needs to be moved into the catkin/src directory that was used for SVO. Once that is done catkin\_make the directory again like above. Also the udev rules in the udev directory in the repository need to be moved to /etc/udev/rules.d/. The following commands will do the above, just replace directories with how it is set up on the system. This all assumes everything is in the home directory of the user. 
\begin{lstlisting}[language=bash]
$ cd
$ git clone https://github.com/SDSMT-CSC464-F15/landingpad
$ cd landingpad
$ cp -r flight_controller ../catkin_ws/src
$ cp udev/* /etc/udev/rules.d/
$ cd ../catkin_ws
$ catkin_make
$ source /devel/setup.bash
\end{lstlisting}
After all the steps are completed, the system is now ready for use and the user can run through the usage documentation on how to run everything that has just been installed. The next section will cover the instructions for the odroid.

\subsection{Setting Up the Odroid}
To set up the odroid that will be attached to the UAV the instructions for burning an image can be found here \url{http://odroid.com/dokuwiki/doku.php?id=en:odroid_flashing_tools}. The image that is required is the same as the odroid xu3 found at \url{http://odroid.com/dokuwiki/doku.php?id=en:xu3_release_linux_ubuntu}. It will be less demanding on the odroid if the sever version of the xu3 is used instead a desktop variant. Also space will be saved since a user interface is not necessary to run the commands on the odroid.\\
\\
Once the odroid is booting properly connect it to a monitor or ssh into it through the network to complete the rest of the installation. Before installing anything run the following command in the console:
\begin{lstlisting}[language=bash]
$ export ARM_ARCHITECTURE=True
\end{lstlisting}
After the above command is run the instructions for creating the directories and compiling the cmake libraries will work just like the workstation. However, the link above for the ROS directions is for a laptop or desktop computer that will be running ROS. The directions change since the odroid is a single board computer that uses the ARM architecture. The instructions for this can be found on the ROS website at \url{http://wiki.ros.org/indigo/Installation/UbuntuARM}. The rest of the instructions in the workstation section can be followed once ROS is installed on the odroid. Only the flight controller directory and udev rules from the repository should go on the odroid so space is not taken up by documents such as the design document and other miscellaneous items.

%% \newpage  %%  if needed ...
\section{User Guide}
Once all the software is installed successfully everything can start to be tested and ran. Make sure the ROS install is sourced correctly as well as the catkin workspace that was created during the installation section.\\
\\
This Section will cover how to run the flight controller code that was used to demonstrate offboard control, Ar-Track-Alvar for the tracking of ar tags, and the visual odometry package SVO for position estimates.\\
\\
The tools that will be used to run these packages and associated ros nodes will be roslaunch, and rosrun. More detail is given the the programmers manual on usage with ROS specific commands. 
\subsection{Flight Controller}
The flight controller node is a simple python node that can control the UAV by sending vectors of direction to go where the origin is where the UAV was turned on. The node is currently is not part of a launch file so switching between terminals will be necessary to get this running.
\subsection{Ar-Track-Alvar}
\subsection{SVO}

\section{Programmer Manual}
To write more software to control the UAV a meta-operating system known as the Robot Operating System (ROS) is needed. ROS is the framework of everything used in this project. Other frameworks such as Mavlink could be used, however that requires writing much of the software without the basis of the communication that ROS can provide. The following subsection will describe ROS and some of the tools used in running the packages in the user guide.
\subsection{ROS}
ROS was the main the tool used in getting all the software to work together as well as many of the libraries in ROS are required to get different nodes to communicate with each other. The framework of ROS is complicated, but at its core it is an easy way to get different modules of code to communicate to each other. It has software built in that will allow a user to visualize the data that is getting streamed across the ROS network known as ROS topics.\\
\\
ROS provides wrappers for interfacing with low level libraries such as Mavlink. This allows data to get streamed accros ROS topics for the user to see what GPS location the flight controller and other useful information. The visulization tools such as Rviz allow a user to see pose information between a camera and ar tag for example as well as the map.\\
\\
\subsubsection{Core ROS Tools}
This section will cover the tools used specifically in the user guide. More information can be found at the ROS wiki regarding other tools or more in depth explanations.\\
\\
Roscore is a collection of nodes and programs that are pre-requisites of a ROS-based system. You must have a roscore running in order for ROS nodes to communicate. It is rand by using the roscore command.
\begin{lstlisting}[language=bash]
$ roscore
\end{lstlisting}
Rosrun allows you to run an executable in an arbitrary package from anywhere without having to give its full path.
\begin{lstlisting}[language=bash]
$ rosrun package executable
\end{lstlisting}
Roslaunch is a tool for easily launching multiple ROS nodes locally and remotely via SSH, as well as setting parameters on the Parameter Server. roslaunch can be run by executing the following commands.
\begin{lstlisting}[language=bash]
$ roslaunch package_name file.launch
\end{lstlisting}
Rostopic contains the rostopic command-line tool for displaying debug information about ROS Topics, including publishers, subscribers, publishing rate, and ROS Messages.
\begin{lstlisting}[language=bash]
$ rostopic list
$ rostopic echo topic_name
\end{lstlisting}
\subsubsection{Programming with ROS}
Information regarding programming in ROS can be found on the wiki page in the tutorial page for writing a simple publisher and subscriber in C++ and python. The flight controller node is example of python node that subscribes to information from the Pixhawk topics and also for publishing to topics for the Pixhawk to be controlled. Examples of more ROS code and be found at \url{https://github.com/smd-ros-devel}. The following listing is the flight controller code used to demonstrate offboard control. Instead of using global functions for callbacks as in the simple examples on the ROS wiki it uses a class structure to encapsulate the callbacks so data isn't global.
\lstinputlisting{code/flight_controller.py}
