% !TEX root = DesignDocument.tex

\chapter{User Documentation}

This chapter will cover the usage instructions and how to install the software required to get the UAV up and running with a Pixhawk flight controller and an odroid xu4 companion computer. The User Guide section will cover how to run all the software installed during the Installation Guide. The Programmer Manual section will cover where to get up to speed with programming in ROS, as well as details regarding the flight controller code that was used to demonstrate offboard control.

%% \newpage  %%  if needed ...
\section{Installation Guide}
The following two sections will go through the set up of a laptop or desktop as a workstation and the odroid that will be attached to the UAV.
\subsection{Setting Up a Workstation}
To set up the workstation the first thing that is required is a computer with \href{http://www.ubuntu.com/download/desktop}{Ubuntu} 14.04 Long Term Support(LTS) installed as the operating system. 
\subsubsection{Dependencies}
Once an Ubuntu machine is acquired make sure git and cmake are installed by running the following commands: 
\begin{lstlisting}[language=bash]
$ sudo apt-get install git
$ sudo apt-get install cmake
\end{lstlisting}
Then create the following two directories:
\begin{lstlisting}[language=bash]
$ mkdir -p catkin_ws/src cmake_ws
\end{lstlisting}
These directories will be used to manage the libraries and software required by the UAV. The cmake\_ws will contain the source of the libraries required by a semi-direct monocular visual odometry pipeline package in ROS also known as SVO. The catkin\_ws directory will contain the source for SVO and other packages that will be written and downloaded for the UAV. Before any of the ROS packages can be installed the dependencies for SVO will need to be installed. \\
\\
The following commands will install Sophus which is required by SVO:
\begin{lstlisting}[language=bash]
$ cd cmake_ws
$ git clone https://github.com/strasdat/Sophus.git
$ cd Sophus
$ git checkout a621ff
$ mkdir build
$ cd build
$ cmake ..
$ make
\end{lstlisting}
The following commands will install Fast detector which is used by SVO to detect corners:
\begin{lstlisting}[language=bash]
$ cd cmake_ws
$ git clone https://github.com/uzh-rpg/fast.git
$ cd fast
$ mkdir build
$ cd build
$ cmake ..
$ make
\end{lstlisting}
Once Sophus and Fast are installed the ROS packages can start to be installed to the system.
\subsubsection{ROS}
To install ROS, refer to \url{http://wiki.ros.org/indigo/Installation/Ubuntu}. It will always have the most up to date installation instructions for installing ROS indigo onto Ubuntu. Everything has successfully worked under both indigo and jade versions of ROS. If ROS jade has reached EOL then indigo should be used. The commands and links are given with ros-indigo instead of ros-jade for this purpose.\\
\\ 
To install mavros, ar-track-alvar, and the camera driver the following commands needs to be executed:
\begin{lstlisting}[language=bash]
$ sudo apt-get install ros-indigo-mavros*
$ sudo apt-get install ros-indigo-ar-track alvar
$ sudo apt-get install ros-indigo-pointgrey-camera-driver
\end{lstlisting}
In order to install ROS packages the catkin workspace will have to be initialized so that ROS libraries can be found for ROS packages that are written by a user or to compile source code. \\
\\
To initialize the catkin workspace execute the following:
\begin{lstlisting}[language=bash]
$ cd catkin_ws/src
$ catkin_init_workspace
$ cd ..
$ catkin_make
$ source devel/setup.bash
\end{lstlisting}
The source command above can be added to the .bashrc file in the home directory so the workspace doesn't have to be explicitly sourced. This will allow usage of packages compiled in this directory without having to remember to source it. \\
\\
Before SVO can be installed a ROS dependency vikit will need to be downloaded into the workspace alongside SVO.
\begin{lstlisting}[language=bash]
$ cd catkin_ws/src
$ git clone https://github.com/uzh-rpg/rpg_vikit.git
$ git clone https://github.com/uzh-rpg/rpg_svo.git
$ cd ..
$ catkin_make
\end{lstlisting}
Once all the previous software is set up, a couple of items need to be moved to specific directories on the system. The flight controller directory in the landingpad repository needs to be moved into the catkin/src directory that was used for SVO. Once that is done catkin\_make the directory again like above. Also the udev rules in the udev directory in the repository need to be moved to /etc/udev/rules.d/. The following commands will do the above, just replace directories with how it is set up on the system. This all assumes everything is in the home directory of the user. 
\begin{lstlisting}[language=bash]
$ cd
$ git clone https://github.com/SDSMT-CSC464-F15/landingpad
$ cd landingpad
$ cp -r flight_controller ../catkin_ws/src
$ cp udev/* /etc/udev/rules.d/
$ cd ../catkin_ws
$ catkin_make
$ source /devel/setup.bash
\end{lstlisting}
After all the steps are completed, the system is now ready for use and the user can run through the usage documentation on how to run everything that has just been installed. The next section will cover the instructions for the odroid.

\subsection{Setting Up the Odroid}
To set up the odroid that will be attached to the UAV the instructions for burning an image can be found here \url{http://odroid.com/dokuwiki/doku.php?id=en:odroid_flashing_tools}. The image that is required is the same as the odroid xu3 found at \url{http://odroid.com/dokuwiki/doku.php?id=en:xu3_release_linux_ubuntu}. It will be less demanding on the odroid if the sever version of the xu3 is used instead a desktop variant. Also space will be saved since a user interface is not necessary to run the commands on the odroid.\\
\\
Once the odroid is booting properly connect it to a monitor or ssh into it through the network to complete the rest of the installation. Before installing anything run the following command in the console:
\begin{lstlisting}[language=bash]
$ export ARM_ARCHITECTURE=True
\end{lstlisting}
After the above command is run the instructions for creating the directories and compiling the cmake libraries will work just like the workstation. However, the link above for the ROS directions is for a laptop or desktop computer that will be running ROS. The directions change since the odroid is a single board computer that uses the ARM architecture. The instructions for this can be found on the ROS website at \url{http://wiki.ros.org/indigo/Installation/UbuntuARM}. The rest of the instructions in the workstation section can be followed once ROS is installed on the odroid. Only the flight controller directory and udev rules from the repository should go on the odroid so space is not taken up by documents such as the design document and other miscellaneous items.

%% \newpage  %%  if needed ...
\section{User Guide}
Once successfully installed the packages can now be tested on the system. Make sure the ROS install is sourced correctly as well as the catkin workspace that was created during the installation section.\\
\\
This Section will cover how to run the flight controller code that was used to demonstrate offboard control, Ar-Track-Alvar for the tracking of ar tags, and the visual odometry package SVO for position estimates.\\
\\
A couple of ROS tools will be used to run the nodes that were downloaded and installed. The tools in ROS that will be used to run these commands are detailed in the following section in the programmers manual.

\subsection{Flight Controller}
The flight controller node can controll the UAV once it is switched into offboard mode. It publishes vectors from its origin to its goal position. To run this make sure the Pixhawk is plugged into either the workstation or odroid. If everything is being ran on the odroid the user will need multiple ssh sessions or screen. To run the flight controller node execute the following commands:
\begin{lstlisting}[language=bash]
$ roslaunch flight_controller px4.launch
$ rosrun flight_controller flight_controller
\end{lstlisting}
Once the above commands are executed the topics can be viewed by using rostopic list or rostopic echo. The flight controller node will wait until a position is reached based on the setpoint local topics. The end goal is published in the console for the first three points so the user can verify that it reaches the positions appropriately. 
\subsection{Ar-Track-Alvar}
Ar-track-alvar is the node that calculates the pose of a camera relative to an ar tag that is in its line of sight. This node can be ran by running the following commands depending on the camera that is used. If the user wants to use a different camera besides the ones provided they will need to calibrate the camera with the ROS camera calibration node. The commands are:
\begin{lstlisting}[language=bash]
$ roslaunch flight_controller webcam.launch
$ rosrun rviz rviz
\end{lstlisting}
Once rviz opens there will be a section on the left side where a camera topic, marker topic, and the transform (TF) topic can be added to visualize the camera and ar tags.
\subsection{SVO}
SVO is the visual odometry node that is used to give pose estimates to the Pixhawk based on the camera. To run the SVO node run the following commands:
\begin{lstlisting}[language=bash]
$ roslaunch flight_controller webcam_svo.launch
$ rostopic echo <pose_topic>
\end{lstlisting}
\section{Programmer Manual}
To write more software to control the UAV a meta-operating system known as the Robot Operating System (ROS) is needed. ROS is the framework of everything used in this project. Other frameworks such as Mavlink could be used, however that requires writing much of the software without the basis of the communication that ROS can provide. The following subsection will describe ROS and some of the tools used in running the packages in the user guide.
\subsection{ROS}
ROS was the main tool used in getting all the software to work together. The libraries in ROS are required to get different nodes to communicate with each other. The framework of ROS is complicated, but at its core it is an easy way to get different modules of code to communicate to each other. It has software built in that will allow a user to visualize the data that is getting streamed across the ROS network known as ROS topics.\\
\\
ROS provides wrappers for interfacing with low level libraries such as Mavlink. This allows data to get streamed across ROS topics for the user to see what GPS location the flight controller has and other useful information. The visualization tools such as Rviz allow a user to see pose information between a camera and ar tag. Other information such as the map can also be viewed.

\subsubsection{Core ROS Tools}
This section will cover the tools used specifically in the user guide. More information can be found at the ROS wiki regarding other tools or more in depth explanations.\\
\\
Roscore is a collection of nodes and programs that are pre-requisites of a ROS-based system. You must have a roscore running in order for ROS nodes to communicate. It is ran by using the roscore command.
\begin{lstlisting}[language=bash]
$ roscore
\end{lstlisting}
Rosrun allows you to run an executable in an arbitrary package from anywhere without having to give its full path.
\begin{lstlisting}[language=bash]
$ rosrun package executable
\end{lstlisting}
Roslaunch is a tool for easily launching multiple ROS nodes locally and remotely via SSH, as well as setting parameters on the Parameter Server. Roslaunch can be run by executing the following commands.
\begin{lstlisting}[language=bash]
$ roslaunch package_name file.launch
\end{lstlisting}
Rostopic contains the rostopic command-line tool for displaying debug information about ROS Topics, including publishers, subscribers, publishing rate, and ROS Messages.
\begin{lstlisting}[language=bash]
$ rostopic list
$ rostopic echo topic_name
\end{lstlisting}
Rviz is a 3D visualization tool for ROS. This node allows for the 
\begin{lstlisting}[language=bash]
$ rosrun rviz rviz
\end{lstlisting}
\subsubsection{Programming with ROS}
Information regarding programming in ROS can be found on the wiki page in the tutorial page for writing a simple publisher and subscriber in C++ and python. The flight controller node is example of python node that subscribes to information from the Pixhawk topics and also for publishing to topics for the Pixhawk to be controlled. Examples of more ROS code and be found at \url{https://github.com/smd-ros-devel}. The following listing is the flight controller code used to demonstrate offboard control. Instead of using global functions for callbacks as in the simple examples on the ROS wiki it uses a class structure to encapsulate the callbacks so data isn't global.
\lstinputlisting{code/flight_controller.py}
